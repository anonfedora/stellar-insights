input {
  # TCP input for structured logs from Rust backend
  tcp {
    port => 5000
    codec => json_lines
    type => "rust-backend"
  }
  
  # HTTP input for webhook/batch logs
  http {
    port => 5001
    type => "http-logs"
  }
  
  # Beats input for system metrics (optional)
  beats {
    port => 5044
    type => "beats"
  }
}

filter {
  # Normalize log level field
  if [level] {
    mutate {
      rename => { "level" => "log_level" }
    }
  }
  
  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ssZ" ]
      target => "@timestamp"
      remove_field => ["timestamp"]
    }
  }
  
  # Add service metadata
  mutate {
    add_field => { 
      "service" => "stellar-insights"
      "[@metadata][index_prefix]" => "stellar-insights"
    }
  }
  
  # Parse request_id if present
  if [request_id] {
    mutate {
      add_field => { "trace_id" => "%{request_id}" }
    }
  }
  
  # Extract error information
  if [log_level] == "ERROR" or [log_level] == "error" {
    mutate {
      add_tag => ["error"]
    }
    
    # Parse error stack trace if present
    if [error] {
      mutate {
        add_field => { "error_message" => "%{[error][message]}" }
      }
    }
  }
  
  # Tag warnings
  if [log_level] == "WARN" or [log_level] == "warn" {
    mutate {
      add_tag => ["warning"]
    }
  }
  
  # Parse HTTP request logs
  if [http_method] {
    mutate {
      add_tag => ["http_request"]
    }
    
    # Calculate response time if available
    if [response_time_ms] {
      ruby {
        code => "
          response_time = event.get('response_time_ms')
          if response_time
            event.set('response_time_seconds', response_time.to_f / 1000.0)
          end
        "
      }
    }
  }
  
  # Parse RPC call logs
  if [rpc_method] {
    mutate {
      add_tag => ["rpc_call"]
    }
  }
  
  # Parse database query logs
  if [query] {
    mutate {
      add_tag => ["database"]
    }
  }
  
  # GeoIP enrichment for IP addresses (optional)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Remove sensitive fields
  mutate {
    remove_field => ["password", "api_key", "secret", "token", "authorization"]
  }
}

output {
  # Output to Elasticsearch with daily indices
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    user => "${ELASTICSEARCH_USERNAME:elastic}"
    password => "${ELASTICSEARCH_PASSWORD:changeme}"
    
    # Index template for better performance
    template_name => "stellar-insights"
    template_overwrite => true
  }
  
  # Output errors to separate index for alerting
  if "error" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "stellar-insights-errors-%{+YYYY.MM.dd}"
      user => "${ELASTICSEARCH_USERNAME:elastic}"
      password => "${ELASTICSEARCH_PASSWORD:changeme}"
    }
  }
  
  # Debug output (disable in production)
  if "${LOGSTASH_DEBUG:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
}
